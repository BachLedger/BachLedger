# Agent Handoff Template

## 角色定义

这是所有 Agent 通用的交接文档模板。每个 Agent 在完成工作或即将被替换时，必须填写此文档，确保下一任 Agent 能够快速接手。

**关键约束**：交接文档是 Agent 的"遗产"，下一任 Agent 靠它快速接手。

## 触发时机

- 任务完成时
- 工作被中断时
- 即将超出上下文限制时
- 被明确要求交接时
- 遇到需要升级的阻塞问题时

## 必须完成的内容

### 1. 记录完成的工作

详细列出所有已完成的工作：

```markdown
## 1. 完成的工作

### 1.1 任务完成情况

| 任务 | 状态 | 产出物 | 验证状态 |
|-----|-----|-------|---------|
| 实现 U256::add | ✅ 完成 | primitives/src/u256.rs | 测试通过 |
| 实现 U256::sub | ✅ 完成 | primitives/src/u256.rs | 测试通过 |
| 实现 U256::mul | ⏳ 进行中 | primitives/src/u256.rs | 60% |

### 1.2 代码/文档变更

**新增文件**:
- `/full/path/to/file1.rs` - U256 核心实现
- `/full/path/to/file2.rs` - U256 测试

**修改文件**:
- `/full/path/to/file3.rs`
  - Line 45-67: 添加模块导出
  - Line 100-120: 修复边界检查

**删除文件**:
- `/full/path/to/old_file.rs` - 合并到新文件

### 1.3 测试状态

```
测试结果:
- 总数: 50
- 通过: 48
- 失败: 2 (见下文)
- 跳过: 0

覆盖率: 85%
```

**失败的测试**:
- `test_mul_overflow`: 大数乘法边界未处理
- `test_div_zero`: 除零检查待实现
```

### 2. 记录未完成的工作和当前进度

明确说明每个未完成任务的状态：

```markdown
## 2. 未完成的工作

### 2.1 进行中的任务

#### 任务: 实现 U256::mul

**当前进度**: 60%

**已完成部分**:
- [x] 接口定义
- [x] 小数乘法 (64位以内)
- [ ] 大数乘法 (Karatsuba算法) ← 当前位置
- [ ] 溢出检测

**当前卡点**:
Karatsuba 算法的递归边界处理有问题，中间结果可能溢出。

**相关代码位置**: `/full/path/primitives/src/u256.rs:145-200`

**继续所需**:
1. 修复递归边界（建议参考 ruint 库实现）
2. 添加中间结果溢出检测
3. 添加测试用例

### 2.2 未开始的任务

| 任务 | 原因 | 前置条件 |
|-----|-----|---------|
| U256::div | 等待 mul 完成 | mul 实现 |
| 性能优化 | 功能优先 | 所有算术完成 |
```

### 3. 记录重要决策及其理由

每个设计决策都要记录为什么这么决定：

```markdown
## 3. 重要决策

### 决策 1: 使用 [u64; 4] 作为 U256 内部表示

**上下文**: 需要选择 U256 的内部存储格式

**考虑的选项**:
1. `[u8; 32]` - 字节数组
   - 优点: 简单，与序列化一致
   - 缺点: 算术运算效率低
2. `[u64; 4]` - 64位块
   - 优点: 算术运算高效，与 CPU 字长对齐
   - 缺点: 需要处理字节序转换

**决定**: 选择 `[u64; 4]`

**理由**:
- 算术是核心操作，效率优先
- 序列化只在边界发生，影响小
- 参考 ethnum、ruint 都采用此方案

**影响**:
- 序列化时需要显式转换字节序
- 需要在文档中说明存储格式

---

### 决策 2: 所有算术使用 checked 版本

**上下文**: 是否使用 wrapping 还是 checked 算术

**决定**: 使用 checked，溢出返回 None

**理由**:
- 安全第一，防止溢出攻击
- Reviewer 和 Attacker 都强调了这一点
- 性能影响可接受（约 5%）
```

### 4. 记录遇到的问题和解决方案

记录踩过的坑和解决办法：

```markdown
## 4. 遇到的问题和解决方案

### 问题 1: Karatsuba 算法中间结果溢出

**现象**:
在计算大数乘法时，中间加法结果超过 U256 范围。

**原因分析**:
Karatsuba 算法需要计算 `(a0 + a1) * (b0 + b1)`，其中 a0+a1 可能超过原数位数。

**解决方案**:
使用临时的更大类型（U512）存储中间结果，或分步计算避免溢出。

```rust
// Before - 可能溢出
let mid = (a0 + a1) * (b0 + b1);

// After - 分步计算
let mid = a0 * b0 + a0 * b1 + a1 * b0 + a1 * b1;
```

**教训**:
- 大数算法需要仔细分析中间结果范围
- 参考成熟实现而非自己设计

---

### 问题 2: [已解决的其他问题]
...
```

### 5. 给下一任的建议

提供具体可操作的建议：

```markdown
## 5. 给下一任的建议

### 5.1 优先处理

1. **修复 mul 的 Karatsuba 实现** - 目前是最大阻塞项
2. **然后实现 div** - 依赖 mul

### 5.2 注意事项

- ⚠️ U256 的 limb 顺序是 little-endian，limb[0] 是最低位
- ⚠️ 测试时用 proptest 对比 num-bigint 的结果
- ⚠️ 不要用 release 模式调试，溢出检查会被优化掉

### 5.3 避免踩坑

| 坑 | 如何避免 |
|---|---------|
| 字节序混淆 | 始终使用 from_le_bytes/to_le_bytes |
| 中间结果溢出 | 使用 checked 操作或更大类型 |
| 测试不充分 | 用 proptest 生成边界用例 |

### 5.4 有用的资源

- `ruint` 库源码: 参考其 U256 实现
- `ethnum` 库: 另一个参考实现
- EIP-152: 预编译合约的数值规范

### 5.5 快速上手命令

```bash
# 构建项目
cargo build -p bach-primitives

# 运行测试
cargo test -p bach-primitives

# 运行特定测试
cargo test -p bach-primitives test_mul

# 检查代码
cargo clippy -p bach-primitives
```

### 5.6 环境状态

```
当前分支: feature/u256-impl
最后提交: abc123 "feat(primitives): add U256 add/sub"
未提交更改:
  - primitives/src/u256.rs (mul 实现中)
```
```

## 完整交接模板

```markdown
# Agent 交接文档

## 基本信息
- **Agent 角色**: [Coder/Tester/Reviewer/Attacker/Documenter]
- **交接时间**: [ISO 8601 时间戳]
- **任务阶段**: [Step 1/2/3/4]
- **工作时长**: [开始时间] - [结束时间]

---

## 1. 完成的工作

### 1.1 任务完成情况

| 任务 | 状态 | 产出物 | 验证状态 |
|-----|-----|-------|---------|
| [任务1] | ✅ 完成 | [文件] | [测试/Review] |
| [任务2] | ⏳ 进行中 | [文件] | [进度%] |
| [任务3] | ❌ 未开始 | - | - |

### 1.2 代码/文档变更

**新增文件**:
- `[完整路径]` - [说明]

**修改文件**:
- `[完整路径]` - [变更说明]

### 1.3 测试状态

```
测试总数: XX
通过: XX
失败: XX
覆盖率: XX%
```

---

## 2. 未完成的工作

### 2.1 进行中的任务

#### 任务: [名称]

**当前进度**: [百分比]

**已完成**:
- [x] [步骤1]
- [ ] [步骤2] ← 当前位置

**卡点**: [描述]

**代码位置**: `[文件:行号]`

**继续所需**: [具体步骤]

### 2.2 未开始的任务

| 任务 | 原因 | 前置条件 |
|-----|-----|---------|

---

## 3. 重要决策

### 决策 1: [标题]

**上下文**: [为什么需要决策]

**选项**:
1. [选项A] - [优缺点]
2. [选项B] - [优缺点]

**决定**: [选择]

**理由**: [为什么]

**影响**: [会影响什么]

---

## 4. 遇到的问题和解决方案

### 问题 1: [标题]

**现象**: [描述]

**原因**: [分析]

**解决**: [方案]

**教训**: [学到什么]

---

## 5. 给下一任的建议

### 5.1 优先处理
1. [最重要的事]
2. [次重要的事]

### 5.2 注意事项
- ⚠️ [注意1]
- ⚠️ [注意2]

### 5.3 避免踩坑
| 坑 | 避免方法 |
|---|---------|

### 5.4 有用资源
- [资源1]: [链接/位置]

### 5.5 快速上手
```bash
# 构建
cargo build

# 测试
cargo test
```

### 5.6 环境状态
```
分支: [branch]
提交: [hash] "[message]"
未提交: [list]
```

---

## 交接检查清单

- [ ] 所有完成工作已记录
- [ ] 未完成工作有明确进度和卡点
- [ ] 重要决策有理由
- [ ] 问题和解决方案已记录
- [ ] 给下一任的建议具体可操作
- [ ] 代码处于可编译状态
- [ ] 无敏感信息泄露
```

## 紧急交接模板

如果 Agent 必须立即停止（错误、超时等）：

```markdown
# 紧急交接

**Agent**: [角色]
**原因**: [错误/超时/其他]
**时间**: [时间戳]

## 最后状态
- 正在做: [什么]
- 进度: [多少]
- 编辑中的文件: [列表]

## 关键警告
[下一任必须知道的最重要的事]

## 恢复步骤
1. [如何继续]
```

## 交接确认

接收交接的 Agent 应该：

1. **确认收到**：确认交接文档已收到
2. **验证产出物**：确认所有文件都存在
3. **检查状态**：确认环境状态与描述一致
4. **运行测试**：确认测试状态与描述一致
5. **提出疑问**：如有不清楚的地方立即询问

```markdown
# 交接确认

**接收 Agent**: [角色]
**时间**: [时间戳]

## 验证结果
- 产出物验证: [YES/NO]
- 状态验证: [YES/NO]
- 测试验证: [YES/NO]

## 需要澄清
[问题列表]

## 开始执行
[首先要做的事]
```

## 关键约束

### 必须做
1. **诚实记录**：如实反映工作状态，不夸大不隐瞒
2. **详细说明**：未完成的工作要说明到具体位置
3. **理由充分**：决策要记录为什么这么决定
4. **可操作**：建议要具体可执行
5. **完整路径**：所有文件路径都用绝对路径

### 禁止做
1. **禁止模糊**：不使用"大部分完成"这样的模糊描述
2. **禁止遗漏**：不遗漏重要的问题和决策
3. **禁止假设**：不假设下一任知道某些上下文
4. **禁止留坑**：不留下无法编译或运行的代码
5. **禁止泄露**：不在文档中包含密钥或凭证

## 交接的重要性

> **交接文档是 Agent 的"遗产"**
>
> 当你离开时，你的知识、经验、正在进行的工作，
> 都通过这份文档传递给下一任。
>
> 写得好的交接文档，能让下一任 Agent 在 5 分钟内接手；
> 写得差的交接文档，会让下一任浪费数小时重复你的工作。
>
> **为下一任着想，就像你希望前任为你着想一样。**
